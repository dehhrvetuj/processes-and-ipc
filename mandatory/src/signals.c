#include <stdio.h>   // puts(), printf()
// NOTE: printf/puts/fputs are NOT async-signal-safe; using them in a handler is generally unsafe.
// This program uses them for learning purposes.

#include <signal.h>  // signal(), SIGFPE, SIGSEGV, SIGINT, SIGUSR1
#include <stdlib.h>  // exit(), EXIT_SUCCESS, EXIT_FAILURE (typo in the next comment line is harmless)
#include <unistd.h>  // getpid(), pause()
// pause() suspends the process until any signal is caught and the handler returns.

#include <stdbool.h> // true, false

// Shared flag between signal handler and main code.
// 'volatile sig_atomic_t' is the recommended type for data shared with signal handlers:
//  - 'sig_atomic_t' can be read/written atomically relative to signals.
//  - 'volatile' prevents the compiler from optimizing away reads/writes across handler boundaries.
volatile sig_atomic_t done = 0;

// --- Demo functions that intentionally trigger synchronous signals ---
// NOTE: Both functions below invoke undefined behavior in C.
// Compilers may optimize them away unless variables are 'volatile'. They are here as exercises.
int divide_by_zero() {
  int a = 1;
  int b = 0;
  return a / b;      // Typically raises SIGFPE (arithmetic exception) on many systems.
}

void segfault() {
  int *ptr = NULL;
  *ptr = 42;         // Dereferencing NULL typically raises SIGSEGV (segmentation fault).
}

// Unified signal handler for multiple signals.
// WARNING: Only async-signal-safe functions should be called here. printf/puts/fputs/exit are NOT safe.
// Safer alternatives would be write(2, ...) and _exit(...). Kept as-is for practice.
void signal_handler(int s) {
  switch(s) {
    case SIGFPE:
      // Arithmetic error (e.g., division by zero).
      // fputs to stderr is not async-signal-safe; used here for demonstration.
      fputs("Caught SIGFPE: arithmetic exception, such as division by zero.\n", stderr);
      exit(EXIT_FAILURE);  // Not async-signal-safe; ends the process via normal exit path.
    case SIGSEGV:
      // Invalid memory access.
      fputs("Caught SIGSEGV: segfault.\n", stderr);
      exit(EXIT_FAILURE);
      break;               // Unreachable after exit(), but harmless.
    case SIGINT:
      // Typically generated by Ctrl+C on the controlling terminal.
      fputs("Caught SIGINT: interactive attention signal, probably a ctrl+c.\n", stderr);
      done = 1;            // Communicate to main loop that we should stop.
      break;               // Return to interrupted point; pause() will return and loop can exit.
    case SIGUSR1:
      // User-defined signal (1). Use 'kill -USR1 <pid>' to send.
      puts("Hello!");      // Not async-signal-safe; used here as a friendly demo.
      break;
    // (No default: branch; other signals are not explicitly handled.)
  }
}

int main(void) {

  // Print our PID so we can 'kill -USR1 <pid>' or 'kill -INT <pid>' from another shell.
  printf("My PID = %ld\n", (long) getpid());

  // Install signal handlers.
  // NOTE: 'signal()' is simple but has some portability quirks; 'sigaction()' is preferred in production.
  signal(SIGFPE,  signal_handler);
  signal(SIGSEGV, signal_handler);
  signal(SIGINT,  signal_handler);
  signal(SIGUSR1, signal_handler);

  // Optional crash demos (commented out). Uncomment one to test synchronous delivery.
  // divide_by_zero();  // Likely triggers SIGFPE and exits via handler.
  // segfault();        // Likely triggers SIGSEGV and exits via handler.

  // --- Waiting for signals section ---
  // 'pause()' sleeps until *any* signal is caught and its handler returns, then pause() returns -1 (EINTR).
  // This loop structure relies on that behavior:
  //   1) pause() blocks until a signal arrives.
  //   2) handler runs; may set 'done' (e.g., on SIGINT).
  //   3) pause() returns -1 -> condition 'while(pause())' evaluates as true (since -1 != 0).
  //   4) In the loop body we check 'done' and break if set.
  //
  // Caveat (classic): there is a small race if a signal arrives *before* entering pause();
  // in robust code you'd prefer 'sigprocmask' + 'sigsuspend' to avoid missing signals.
  // For this exercise, this pattern is acceptable to practice handler flow.
  //pause();
  while (pause())
  {
    if (done) break;  // Set by SIGINT handler to request graceful shutdown.
  };

  // If we reach here, either SIGINT set 'done', or some other path broke the loop.
  puts("I'm done!");

  // Normal exit path for the process (as opposed to exit() inside the handler for fatal signals).
  exit(EXIT_SUCCESS);
}
